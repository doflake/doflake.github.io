---
title: '[Ex] 007 洛谷 P1449 后缀表达式 题解'
mathjax: true
date: 2020-11-26 20:37:28
link_c: Explanation
link_name: Luogu-P1449-Postfix-Expression
top: 4000
---

题目要求输入的字符串---然后改成数字。其实学过快读的人一眼就可以发现，这道题把朴素的快读模板代码稍稍修改就可以完成数字读入部分：

<!--more-->

```cpp
while (1){
	scanf("%c",&c);
	if('0'<=c and c<='9'){
		tot=tot*10+c-'0'; 
	}
	else if(c=='.'){
		st[++top]=tot;
		tot=0;
	}
   ... ...
}

```
对于没有学过快读的同学，怎么理解这串读入代码呢？我们复习一下小学知识（以2345为例）：

| 数字 |2  | 3 | 4 | 5 |
| -----------: | -----------: | -----------: | -----------: | -----------: |
|数位  | 千位 | 百位 | 十位 | 个位 |
| 计数单位 | 千 | 百 | 十 | 一 |

这代表什么呢？千位上的1代表一个千，所以千位上的2代表2000，百位上的1代表一个百，所以百位上的3代表3000以此类推。

现在，我们输入了一个2，它现在在个位，于是用于保存这个数的变量tot就加上2.

然后，我们输入了一个3，那个2到了十位，也就是原来的2现在代表20，怎么办呢？我们把tot乘上10，再加上3，tot就变成了23.

接着，我们输入了4,那么2和3分别左移一位，也就是原来的23现在代表230.这还是把tot乘上10,再加上4就可以办到的事。

最后，我们用同样的方法将234左移一位，加上5，就完成了2345的输入。


现在解决了输入数字，我们可以进行进一步分析。

首先，后缀表达式是什么？这。。。[看看这个](https://baike.baidu.com/item/%E9%80%86%E6%B3%A2%E5%85%B0%E5%BC%8F/128437?fromtitle=%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F&fromid=6160580&fr=aladdin)

我们要对后缀表达式进行计算。以3．5．2．-*7．+@为例子：

|输入3.  |  3.|
| :----------- | :----------- |
| 输入5. | 3,5. |
| 输入2. | 3,5,2. |
| 输入- | 3,（5-2） |
| 输入* | 3*（5-2） |
| 输入7. | 3*（5-2），7 |
| 输入+ | 3*（5-2）+7 |

从其中不难看出，每输入一个运算符号，只会对最后两个数字产生影响，也就是将最后两个数通过这种运算变成一个数，这符合栈的特点。想到了栈，再进行分析，就不难发现，这其实是一道水题，伪代码如下：

>for(;;){
>
>	输入一个字符
>   
>  如果是数字：按照处理数字的方法处理
 
>  如果是‘.’：压入栈
 
>  如果是运算符号：弹出栈，弹出栈，将两个弹出的数进行相应的运算之后压入栈
 
>	如果是‘@’：终止

>}

然后就可以开始写代码咯！

```cpp
#include"iostream"
#include"algorithm"
#include"stdio.h"
using namespace std;
#define maxn 1000+5
int st[maxn];int top=0;//数组模拟栈 
void scanff(){
	char c; int tot=0;
	while(1){//一直进行直到有'@' 
		scanf("%c",&c);//输入 
		if('0'<=c and c<='9'){//是数字 
			tot=tot*10+c-'0'; 
		}
		else if(c=='.'){//是'.' 
			st[++top]=tot;//压入栈 
			tot=0;		  //##重点##清零 
		}	
		else if (c==10) continue;//屏蔽回车干扰 
		else{					 //是运算符号 
			int t;				 //下一个要被压入栈的元素 
			switch (c){			 //以下内容极其容易理解 
				case '+' :
					t=st[top-1]+st[top];break;
				case '-' :
					t=st[top-1]-st[top];break;//##重点##注意顺序 
				case '*' :
					t=st[top-1]*st[top];break;
				case '/' :
					t=st[top-1]/st[top];break;//##重点##注意顺序 
				case '@' :return ;
				default :break;
			}
			st[--top]=t;//弹出了两个元素后压入一个元素，所以用--top 
		}
	}
	return ;
}
int main(){
	scanff();//容易理解 
	printf("%d\n",st[1]);//最后应当只留下了st[1]。 
	return 0;//世界终结 
}
```

## By Error_Eric