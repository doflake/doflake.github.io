---
title: '[Ex] 006 洛谷 P1094 纪念品分组 题解'
mathjax: true
date: 2020-11-26 20:33:38
link_c: Explanation
link_name: Luogu-P1094-Souvenir-Group
top: 4000
---


要做出这道题，首先得弄清楚我们如何贪心。

<!--more-->

乐乐帮了我们一个大忙，他把纪念品按大小排好序，拿来了一些箱子，准备把纪念品装进箱子里面送给同学们。

显然，最好一个箱子里能放下两个纪念品，我们可以先把大的纪念品放进箱子里，那么最理想的状态即：

```
第一个箱子：p[1]+p[n]
第二个箱子：p[2]+p[n-1]
……
第i 个箱子：p[i]+p[n-i]

注：虽然可能有同等优的解，但没有更优解。

```

显然这是不可能的，（否则乐乐不需要帮助），那么如何得到最优解呢？

我们可以用快排之中用到过的双指针法，如果这两个纪念品无法装在同一个箱子里，那么大的那个纪念品单独装箱，那么用掉的纪念品总体积更多，符合贪心思想，代码即 ： 
$$j--,ans++$$

如果指到的两个箱子可以同时装箱的话，就两个都装进去
~~（当然）~~
：

$$j--,i++,ans++$$

代码实现如下：
```cpp
#include<stdio.h>
#include<algorithm>
using namespace std;
int w,n,i=1,j,ans;//箱子大小，物品个数，两个指针，箱子个数
int p[30000+5];//物品大小
int main(){
	scanf("%d\n%d",&w,&n);//输入
	for(int fi=1;fi<=n;fi++)//输入
		scanf("%d",&p[fi]);//输入
	sort(p+1,p+1+n);j=n;//排序(壮哉c++,壮哉STL)
    	//以及指针初始化
	while(i<=j){//中间那个'='必须加
		if(p[i]+p[j]>w)//情况1
       			j--,ans++;
		else 	       //情况2
        		i++,j--,ans++;
	}
	printf("%d\n",ans);//输出
    return 0;//乐乐感谢你的帮助
}
```
经过帮助，乐乐分发完了纪念品。

## 转载自 Error_Eric